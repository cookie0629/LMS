# LMS 项目从零开始实现计划

## 📋 目录
1. [实现原则](#实现原则)
2. [阶段划分](#阶段划分)
3. [详细实施步骤](#详细实施步骤)
4. [每个阶段的学习目标](#每个阶段的学习目标)

---

## 实现原则

### ✅ 允许的做法
- **参考模板的设计思路**：理解为什么这样设计
- **学习架构模式**：接口、服务定位器等
- **理解数据流**：数据如何流动和处理
- **概念优先**：先理解概念，再写代码

### 🚫 禁止的做法
- **直接复制模板代码**：每一行代码都要自己写
- **跳过理解直接实现**：必须理解为什么这样做
- **一次性实现大功能**：小步前进，逐步验证

### 📚 学习方式
1. **分析模板**：理解设计思路和架构
2. **制定计划**：基于理解制定实现步骤
3. **手写代码**：从空文件开始，逐步实现
4. **测试验证**：每个小功能都要测试
5. **迭代改进**：根据问题调整实现

---

## 阶段划分

### 阶段 0：基础准备（已完成 ✅）
- [x] 环境搭建
- [x] 项目结构创建
- [x] 基础 CMakeLists.txt
- [x] 简单 main.cpp

### 阶段 1：Core 库基础（第 1-2 周）
**目标**：实现最基础的工具类

### 阶段 2：配置和日志系统（第 2-3 周）
**目标**：实现配置管理和日志系统

### 阶段 3：数据库基础（第 3-5 周）
**目标**：实现数据库抽象层和基本数据模型

### 阶段 4：音频处理基础（第 5-7 周）
**目标**：实现音频文件读取和标签解析

### 阶段 5：扫描服务基础（第 7-10 周）
**目标**：实现文件扫描和数据库更新

### 阶段 6：Web UI 基础（第 10-12 周）
**目标**：实现基本的 Web 界面

### 阶段 7：播放功能（第 12-14 周）
**目标**：实现音频播放和播放队列

### 阶段 8：高级功能（第 14 周+）
**目标**：转码、推荐、搜索等

---

## 详细实施步骤

## 阶段 1：Core 库基础（第 1-2 周）

### 1.1 理解 Core 库的作用

**模板分析**：
- Core 库提供**基础设施**，不包含业务逻辑
- 其他模块都依赖 Core 库
- 使用**接口模式**定义抽象

**你的任务**：
1. 阅读模板 `libs/core/include/core/` 中的接口定义
2. 理解每个接口的**目的**和**职责**
3. **不要看实现代码**，只看接口定义

### 1.2 实现第一个工具类：Path

**参考模板思路**：
- 模板有 `core::Path` 类用于路径处理
- 封装文件系统操作
- 提供跨平台支持

**你的实现步骤**：

#### 步骤 1：创建接口文件
```bash
# 创建目录结构
mkdir -p src/libs/core/include/core
mkdir -p src/libs/core/impl
```

创建 `src/libs/core/include/core/IPath.hpp`：
- 定义路径操作接口
- 思考需要哪些功能？（存在检查、是否为目录、获取文件名等）

#### 步骤 2：创建实现文件
创建 `src/libs/core/impl/Path.cpp`：
- 实现接口定义的功能
- 使用 `<filesystem>` 标准库

#### 步骤 3：测试
编写简单的测试程序验证功能

**学习重点**：
- 如何设计接口？
- 接口应该包含哪些方法？
- 如何隐藏实现细节？

### 1.3 实现 String 工具类

**参考模板思路**：
- 字符串工具函数集合
- 大小写转换、分割、trim 等

**你的实现**：
- 逐步添加字符串处理函数
- 每个函数都要测试

### 1.4 实现 UUID 生成

**参考模板思路**：
- UUID v4 生成
- 用于唯一标识

**你的实现**：
- 使用标准库或第三方库
- 理解 UUID 的用途

---

## 阶段 2：配置和日志系统（第 2-3 周）

### 2.1 理解配置系统设计

**模板分析**：
- 使用 `libconfig++` 读取配置文件
- 接口 `IConfig` 定义配置访问方法
- 支持默认值

**你的实现步骤**：

#### 步骤 1：设计配置接口
思考：
- 需要支持哪些数据类型？（string, int, bool, path）
- 如何处理默认值？
- 如何验证配置？

#### 步骤 2：实现配置读取
- 读取 `conf/lms.conf` 文件
- 解析配置项
- 提供访问方法

#### 步骤 3：集成到 main.cpp
- 在程序启动时加载配置
- 使用配置的值

### 2.2 实现日志系统

**模板分析**：
- 日志级别：DEBUG, INFO, WARNING, ERROR
- 支持文件输出和控制台输出
- 使用宏简化日志调用

**你的实现步骤**：

#### 步骤 1：设计日志接口
- 定义日志级别枚举
- 定义日志接口方法

#### 步骤 2：实现日志系统
- 支持不同级别的日志
- 格式化日志输出
- 支持文件和控制台

#### 步骤 3：创建日志宏
- 简化日志调用
- 例如：`LMS_LOG(INFO, "消息")`

---

## 阶段 3：数据库基础（第 3-5 周）

### 3.1 理解数据库架构

**模板分析**：
- 使用 Wt::Dbo ORM
- 数据对象定义在 `objects/` 目录
- Session 管理数据库连接

**学习重点**：
- ORM 的概念
- 对象关系映射
- 数据库迁移

### 3.2 实现数据库接口

**你的实现步骤**：

#### 步骤 1：创建数据库接口
- `IDb.hpp` - 数据库接口
- 定义连接、会话管理方法

#### 步骤 2：实现数据库类
- 使用 Wt::Dbo 连接 SQLite
- 管理数据库会话

#### 步骤 3：创建第一个数据对象：User
- 定义 User 类
- 映射到数据库表
- 实现基本的 CRUD 操作

**学习重点**：
- 如何定义数据对象？
- 如何使用 Wt::Dbo 映射？
- 如何创建和查询数据？

### 3.3 扩展数据模型

逐步添加：
- Track（曲目）
- Artist（艺术家）
- Release（专辑）

理解它们之间的关系

---

## 阶段 4：音频处理基础（第 5-7 周）

### 4.1 理解音频处理架构

**模板分析**：
- 接口与实现分离
- 支持多种解析器（TagLib, FFmpeg）
- 统一的接口抽象

### 4.2 实现音频文件信息接口

**你的实现步骤**：

#### 步骤 1：定义接口
- `IAudioFileInfo.hpp`
- 定义需要获取的信息（时长、比特率、采样率等）

#### 步骤 2：实现 TagLib 解析器
- 学习 TagLib 基本用法
- 实现音频信息读取
- 实现标签读取

#### 步骤 3：测试
- 使用真实的音频文件测试
- 验证信息提取是否正确

---

## 阶段 5：扫描服务基础（第 7-10 周）

### 5.1 理解扫描流程

**模板分析**：
- 扫描服务是核心业务逻辑
- 流程：遍历目录 → 识别文件 → 解析 → 更新数据库

### 5.2 实现基础扫描

**你的实现步骤**：

#### 步骤 1：实现目录遍历
- 递归遍历目录
- 识别音频文件（通过扩展名）

#### 步骤 2：解析音频文件
- 使用之前实现的音频处理接口
- 提取元数据

#### 步骤 3：更新数据库
- 创建/更新 Track 对象
- 关联 Artist 和 Release

---

## 每个阶段的学习目标

### 阶段 1 目标
- ✅ 理解接口设计模式
- ✅ 能够设计清晰的接口
- ✅ 实现基础工具类

### 阶段 2 目标
- ✅ 理解配置管理
- ✅ 实现日志系统
- ✅ 理解服务定位器模式

### 阶段 3 目标
- ✅ 理解 ORM 概念
- ✅ 能够定义数据模型
- ✅ 实现数据库操作

### 阶段 4 目标
- ✅ 理解音频文件格式
- ✅ 能够读取音频元数据
- ✅ 理解接口与实现分离

### 阶段 5 目标
- ✅ 理解文件系统操作
- ✅ 实现完整的扫描流程
- ✅ 理解数据流

---

## 实施建议

### 1. 小步前进
- 每次只实现一个小功能
- 立即测试验证
- 确保可以编译运行

### 2. 理解优先
- 遇到问题先理解概念
- 参考模板的设计思路
- 不要急于实现

### 3. 测试驱动
- 每个功能都要测试
- 使用真实数据测试
- 验证边界情况

### 4. 文档记录
- 记录设计决策
- 记录遇到的问题
- 记录解决方案

### 5. 迭代改进
- 先实现基本功能
- 再优化和完善
- 逐步添加特性

---

## 下一步行动

1. **现在开始阶段 1**：实现 Core 库的第一个工具类
2. **参考模板思路**：理解为什么这样设计
3. **手写代码**：从空文件开始实现
4. **测试验证**：确保功能正确

记住：**理解比实现更重要，小步前进比大步跳跃更稳**！

